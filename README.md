![Fujin logo](./logo-fujin.png)

# Fujin Language Specification


Язык рассчитан для работы в децентрализованных сетях и в цифровых фабриках как более строгая realtime замена TypeScript.  

Это что-то вроде Lua для смартконтрактов, бизнес-логики и описания протоколов сервисов и структур данных.

Синтаксис языка в 10 раз проще, чем TypeScript (по объему кода AST).

Задача Fujin — разделить бизнес-логику и тяжелую обработку данных. Fujin берет на себя все, что касается ветвления и бизнес-логики; все тяжелые вычисления и хранение данных обеспечиваются модулями на Zig.

## Что такое Fujin

Это **строгий, компактный, чистый** язык Fujin. Работает внутри:
- Actor Fabric (гиперконвергентный слой инфраструктуры Solenopsys)
- IR FUJIN (легкая виртуальная машина)
- WASM-модуля с минимальными рантаймами


По сути — язык TS как будто «переписали заново» под требования micro-kernel с actor-моделью.

---

## Файловая структура Fujin

Всего есть 4 типа файлов с иерархией наследования возможностей:

1. `.fjc` - базовый язык (структуры, акторы, без float)
2. `.fjt` - типы и интерфейсы (+ float, + сериализация)
3. `.fjs` - скрипты общего назначения (расширенные операции)
4. `.fjx` - UI компоненты (теги + каскадные обработчики)

### Иерархия наследования

```
.fjc (базовый язык: структуры, акторы, целочисленная арифметика)
  ↓
.fjt (типы и интерфейсы: + float, + аннотации @name, + сериализация)
  ↓
.fjs (скрипты: расширенные операции)
  ↓
.fjx (UI: теговые структуры + каскадные обработчики)
```

Каждый последующий уровень наследует возможности предыдущего и добавляет новые.

---

## Документация по разделам

### Структура языка

0. [**Структура файлов**](./docs/lang/00-file-structure.md)
   - Иерархия типов файлов (.fjt → .fjc → .fjs → .fjx)
   - Наследование возможностей
   - Когда использовать какой тип файла

### Основы языка

1. [**Переменные и примитивы**](./docs/lang/01-variables-primitives.md)
   - Объявление переменных (let, const)
   - Примитивные типы (u8-u64, i8-i64, f32, f64, bool, byte, string)
   - Литералы

2. [**Операторы**](./docs/lang/02-operators.md)
   - Арифметические, логические
   - Операторы сравнения (только строгие ===, !==)
   - Присваивание

3. [**Акторы**](./docs/lang/03-actors.md)
   - `actor` вместо `function`
   - `emit` для отправки сообщений
   - Определение и использование акторов

4. [**Управляющие конструкции**](./docs/lang/04-control-flow.md)
   - Условия (if-else, switch)
   - **Только for** — единственный цикл!
   - `emit` вместо `return`
   - Обработка ошибок (try-catch-finally)

### Структуры данных

5. [**Массивы и объекты**](./docs/lang/05-data-structures.md)
   - Массивы (минимальный набор методов: push, pop, length, slice)
   - Plain objects (POJO) без методов
   - Строки (минимальный набор: length, slice, indexOf, split, concat)
   - Кортежи

### Система типов и Wire Format

6. [**Типы**](./docs/lang/06-types-protocols.md)
   - **Порядок полей имеет значение!**
   - Type aliases, Union types
   - Generics, Nullable

### Модульность

7. [**Модульная система**](./docs/lang/07-modules.md)
   - Import/Export (именованный и default)
   - Экспорт типов
   - Структура модулей

### Аннотации и теги

8. [**Аннотации**](./docs/lang/08-annotations.md)
   - Аннотация `@name()` для сериализуемых типов
   - Ключевое слово `action` для ссылок на акторы
   - Передача через шину и асинхронные вызовы
   - Binary layout и type hash

### Архитектура

9. [**Zero-Runtime модель**](./docs/lang/09-zero-runtime.md)
   - Никаких скрытых аллокаций
   - Lowering: Fujin → IR → WASM → Actor Runtime
   - Детерминированность

10. [**Binary Layout**](./docs/lang/10-binary-layout.md)

- Упаковочный формат (как Cap'n Proto)
- Размеры и alignment примитивов
- Layout типов и padding
- Type hash при компиляции
- Аннотации (@packed, @align)

11. [**Теги**](./docs/lang/11-tags.md)

- Теги как JSX-синтаксис для акторов
- Вложенные компоненты и `children`
- Обработчики событий с `action`
- JSX-синтаксис в `.fjx` файлах

### Специализированные файлы

12. [**Смартконтракты (.fjc)**](./docs/lang/12-smartcontracts.md)

- Детерминированная логика без float
- Работа с деньгами в целых числах
- Примеры токенов, голосования, мультисига
- Best practices для блокчейна

---

## Ключевые принципы Fujin

### Что есть

- **Actor-модель** — `actor` вместо `function`
- **Messaging** — `emit` для отправки сообщений
- **Аннотации** — `@name` для сериализуемых типов и тегов
- **Ссылки на акторы** — `action` для передачи ссылок на акторы
- **Простой язык Fujin** (как Lua для бизнес-логики)
- **Типы = Wire Format** (как Cap'n Proto)
- Type hash при компиляции для идентификации типов
- Строгая типизация без `any`
- Только `for` — единственный цикл
- Plain data объекты и массивы (минимальные методы)
- Zero-runtime — всё lowering в IR → WASM
- Детерминированное выполнение

### Чего нет

- Нет `function` — используйте `actor`
- Нет `return` — используйте `emit`
- Нет классов, прототипов, `new`
- Нет генераторов, `eval`, мета-программирования
- Нет скрытых аллокаций и GC
- Нет циклов `while`, `do-while`, `for-of`
- Нет избыточных методов массивов/строк (все в библиотеках)
- Нет Schema evolution (тип → hash)
- Нет `async/await` — actor-модель
- Нет побитовых операторов
- Нет тернарного оператора
- Нет template literals
- Нет spread оператора

### Результат

**Простой язык** для компилятора + **мощный wire format** для actor messaging → чистый IR → WASM → Actor Runtime
