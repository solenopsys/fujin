# IR: вход/выход через Cap, внутри — плоский стек

Коротко, что решили:
- Входное сообщение не десериализуем в объекты. Делаем `MessageView` на Cap-сегменты и читаем поля по `plan_id`/`field_idx` прямо в слоты (скаляры или `SliceRef`).
- Выходное сообщение строим стримингом: `init_builder` → `set_field_*` / `list_start`+`list_push` → `emit_plan`. Готовый wire Cap, без промежуточной структуры в стеке.
- Слот стека — компактный union: скаляры, `SliceRef` (ptr,len, elem_size) для строк/байт/массивов, `StackSlice` для внутренних blob-ов. Никаких HashMap/ArrayList.
- Опкоды держим короткими (~15–20): const/арифметика/ветвления; `load_field_*`, `slice_len`, `load_elem_*`; примитивы для копирования/конкатенации с аллокатором; builder-операции для выхода.
- Локалки фиксированной формы кладём в плоский фрейм по offset/size; переменной длины — только через срезы и явное выделение под результат.
- Размер фрейма известен при компиляции; если больше страницы стека (4KB по умолчанию) — `FrameOverflow` на компиляции или при `StackRing.acquire`.
